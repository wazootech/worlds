---
title: "RDF & SPARQL"
description: "How the platform handles RDF blobs, N3 stores, and SPARQL queries."
---

## RDF blob handling

- **lib/blob/n3.ts:** Provides utilities to convert between RDF blobs (e.g., N-Quads strings) and N3 Stores (parsing and serialization).
- **lib/blob/sparql.ts:** `sparql(blob, query, handler)` runs queries using Comunica over an N3 store. It wires a `PatchHandler` for updates.

## RDF patching

Centralized in **lib/rdf-patch/mod.ts**, this library provides a unified system for tracking and applying graph mutations.

### Ingestion Flow (`handlePatch`)

The `handlePatch(client, embeddings, patches)` function in **rdf-patch.ts** processes mutations for the world database:

1. **Deterministic Identification**: Each quad is skolemized and hashed to a unique triple ID.
2. **Relational Storage**: Triples are upserted into the `triples` table.
3. **Semantic Indexing**: For literal values, the text is split into chunks and embedded for hybrid search.
4. **Triggers**: SQL triggers automatically sync `rdf:type` relations to the `entity_types` table for optimized structural filtering.

## SPARQL route execution

1. Loads the world (with its blob) from the main DB.
2. Resolves the world client via `databaseManager.get(worldId)`.
3. Runs `handlePatch` with a handler that applies updates to the world client.
4. Executes the SPARQL query over the blob.
5. If the blob changed (on update), the main DB's world row is updated.
